import { Injectable, UnauthorizedException } from "@nestjs/common";
import { LoginDto } from "./dto/login.dto";
import { InjectRepository } from "@nestjs/typeorm";
import { Pessoa } from "src/pessoa/entities/pessoa.entity";
import { Repository } from "typeorm";
import { HashingService } from "./hashing/hashing.service";

@Injectable()
export class AuthService {
    constructor(
        @InjectRepository(Pessoa)
        private readonly pessoaRepository: Repository<Pessoa>,
        private readonly hashingService: HashingService) { }

    async login(loginDto: LoginDto) {
        const { email, password } = loginDto; // ‚¨Ö facilita leitura e evita repetir "loginDto"

        // üîê IMPORTANTE:
        // Se no entity o passwordHash estiver com `select: false`, voc√™ PRECISA selecion√°-lo explicitamente.
        // Ajuste os campos conforme seu entity (ex.: adicione 'nome' se existir).
        const pessoa = await this.pessoaRepository.findOne({
          where: { email },
          select: ["id", "email", "passwordHash"], // adicione "nome" etc. se quiser retornar
        });
        
    
        // ‚ö†Ô∏è N√ÉO redeclare vari√°veis! No seu c√≥digo original, havia um "let isPasswordValid" dentro do if,
        // que SOMBRA a vari√°vel externa e a deixa sempre false.
        // Aqui fazemos a compara√ß√£o numa √∫nica vari√°vel, sem shadowing.
        const isPasswordValid = pessoa
          ? await this.hashingService.compare(password, pessoa.passwordHash) // compare em tempo constante
          : false;
    
        // ‚ùå N√£o revele se foi email ou senha que falhou (evita enumera√ß√£o de usu√°rios)
        if (!isPasswordValid) {
          throw new UnauthorizedException("Email ou senha inv√°lidos");
        }
    
        // ‚úÖ NUNCA retorne o DTO original (ele cont√©m a senha em claro).
        // Retorne dados sanitizados ou gere tokens (JWT / refresh) aqui.
        return {
          email: pessoa?.email,
        };
      }

}